<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sofi Cashflow Tracker</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    const FREQUENCIES = [
      { key: "WEEKLY", label: "Weekly" },
      { key: "BIWEEKLY", label: "Biweekly" },
      { key: "MONTHLY", label: "Monthly" },
    ];

    function uid() {
      return Math.random().toString(36).slice(2) + Date.now().toString(36);
    }

    const toISODate = (d) => new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString().slice(0, 10);
    const parseISO = (s) => {
      const [y, m, d] = s.split("-").map(Number);
      return new Date(y, m - 1, d);
    };
    function addDays(date, n) {
      const d = new Date(date);
      d.setDate(d.getDate() + n);
      return d;
    }
    function addMonths(date, n) {
      const d = new Date(date);
      d.setMonth(d.getMonth() + n);
      return d;
    }
    function nextBiweekly(from, anchor) {
      const oneDay = 24 * 60 * 60 * 1000;
      const start = new Date(anchor);
      const f = new Date(from);
      const diffDays = Math.floor((f - start) / oneDay);
      const mod = ((diffDays % 14) + 14) % 14;
      return addDays(f, mod === 0 ? 0 : 14 - mod);
    }
    function enumerateOccurrences(rule, horizonStart, horizonEnd) {
      const out = [];
      const { frequency, anchorDate } = rule;
      if (!frequency || !anchorDate) return out;
      let cur;
      const start = parseISO(horizonStart);
      const end = parseISO(horizonEnd);
      const anchor = parseISO(anchorDate);
      if (frequency === "WEEKLY") {
        cur = new Date(start);
        while (cur.getDay() !== anchor.getDay()) cur = addDays(cur, 1);
        while (cur <= end) {
          out.push(toISODate(cur));
          cur = addDays(cur, 7);
        }
      } else if (frequency === "BIWEEKLY") {
        cur = nextBiweekly(start, anchor);
        while (cur <= end) {
          out.push(toISODate(cur));
          cur = addDays(cur, 14);
        }
      } else if (frequency === "MONTHLY") {
        let temp = new Date(start);
        temp.setDate(anchor.getDate());
        if (temp < start) temp = addMonths(temp, 1);
        while (temp <= end) {
          const y = temp.getFullYear();
          const m = temp.getMonth();
          const daysInMonth = new Date(y, m + 1, 0).getDate();
          const day = Math.min(anchor.getDate(), daysInMonth);
          const d = new Date(y, m, day);
          if (d >= start && d <= end) out.push(toISODate(d));
          temp = addMonths(temp, 1);
        }
      }
      return out;
    }

    const KEY = "sofi-cashflow-tracker-v1";
    function loadState() {
      try {
        const raw = localStorage.getItem(KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }
    function saveState(state) {
      localStorage.setItem(KEY, JSON.stringify(state));
    }

    function Card({ children, extra }) {
      return <div className={`rounded-2xl bg-white p-4 shadow-sm border border-slate-200 ${extra || ""}`}>{children}</div>;
    }

    function App() {
      const [accountName, setAccountName] = useState("SoFi Checking");
      const [startingBalance, setStartingBalance] = useState(0);
      const [asOfDate, setAsOfDate] = useState(toISODate(new Date()));
      const [lookaheadDays, setLookaheadDays] = useState(45);
      const [oneOffs, setOneOffs] = useState([]);
      const [recurrings, setRecurrings] = useState([]);

      useEffect(() => {
        const s = loadState();
        if (s) {
          setAccountName(s.accountName ?? "SoFi Checking");
          setStartingBalance(s.startingBalance ?? 0);
          setAsOfDate(s.asOfDate ?? toISODate(new Date()));
          setLookaheadDays(s.lookaheadDays ?? 45);
          setOneOffs(s.oneOffs ?? []);
          setRecurrings(s.recurrings ?? []);
        }
      }, []);
      useEffect(() => {
        saveState({ accountName, startingBalance, asOfDate, lookaheadDays, oneOffs, recurrings });
      }, [accountName, startingBalance, asOfDate, lookaheadDays, oneOffs, recurrings]);

      const horizonStart = asOfDate;
      const horizonEnd = toISODate(addDays(parseISO(asOfDate), lookaheadDays));

      const upcoming = useMemo(() => {
        const offs = oneOffs
          .filter((t) => t.date >= horizonStart && t.date <= horizonEnd)
          .map((t) => ({ ...t, kind: "One-off" }));
        const rec = [];
        for (const r of recurrings) {
          const dates = enumerateOccurrences(r.rule, horizonStart, horizonEnd).filter(
            (d) => !r.endDate || d <= r.endDate
          );
          for (const d of dates)
            rec.push({ id: `${r.id}-${d}`, date: d, amount: r.amount, note: r.label, kind: r.rule.frequency });
        }
        const all = [...offs, ...rec].sort((a, b) => a.date.localeCompare(b.date));
        let balance = Number(startingBalance);
        const withRun = all.map((t) => {
          balance += Number(t.amount);
          return { ...t, runBalance: balance };
        });
        const projectedEnd = withRun.length ? withRun[withRun.length - 1].runBalance : Number(startingBalance);
        const firstNegative = withRun.find((t) => t.runBalance < 0);
        return { items: withRun, projectedEnd, firstNegative };
      }, [oneOffs, recurrings, startingBalance, horizonStart, horizonEnd]);

      const [qDate, setQDate] = useState(toISODate(new Date()));
      const [qAmount, setQAmount] = useState(0);
      const [qNote, setQNote] = useState("");
      function addOneOff() {
        if (!qDate || !qAmount) return;
        const t = { id: uid(), date: qDate, amount: Number(qAmount), note: qNote };
        setOneOffs((x) => [t, ...x]);
        setQAmount(0);
        setQNote("");
      }

      const [rLabel, setRLabel] = useState("Paycheck");
      const [rAmount, setRAmount] = useState(2500);
      const [rFrequency, setRFrequency] = useState("BIWEEKLY");
      const [rAnchor, setRAnchor] = useState(toISODate(new Date()));
      const [rEnd, setREnd] = useState("");
      function addRecurring() {
        const r = {
          id: uid(),
          label: rLabel,
          amount: Number(rAmount),
          rule: { frequency: rFrequency, anchorDate: rAnchor },
          endDate: rEnd || undefined,
        };
        setRecurrings((x) => [r, ...x]);
      }
      function removeOneOff(id) {
        setOneOffs((x) => x.filter((t) => t.id !== id));
      }
      function removeRecurring(id) {
        setRecurrings((x) => x.filter((t) => t.id !== id));
      }

      const projectedBadge = upcoming.projectedEnd >= 0 ? "bg-emerald-100 text-emerald-800" : "bg-rose-100 text-rose-800";

      return (
        <div className="min-h-screen w-full bg-slate-50 p-4 sm:p-8">
          <div className="mx-auto max-w-6xl">
            <header className="mb-6">
              <h1 className="text-2xl font-bold">Cashflow Tracker</h1>
              <p className="text-slate-600">Plan your {accountName} balance with recurring and one-off items. Local only.</p>
            </header>

            <section className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
              <Card>
                <div className="text-xs uppercase text-slate-500">Account</div>
                <input className="w-full rounded-xl border p-2" value={accountName} onChange={(e) => setAccountName(e.target.value)} />
              </Card>
              <Card>
                <div className="text-xs uppercase text-slate-500">Starting balance (as of)</div>
                <div className="flex gap-2">
                  <input type="number" className="w-1/2 rounded-xl border p-2" value={startingBalance} onChange={(e) => setStartingBalance(Number(e.target.value))} />
                  <input type="date" className="w-1/2 rounded-xl border p-2" value={asOfDate} onChange={(e) => setAsOfDate(e.target.value)} />
                </div>
              </Card>
              <Card>
                <div className="text-xs uppercase text-slate-500">Lookahead window</div>
                <div className="flex items-center gap-2">
                  <input type="number" className="w-24 rounded-xl border p-2" value={lookaheadDays} onChange={(e) => setLookaheadDays(Number(e.target.value))} />
                  <span className="text-slate-600">days</span>
                </div>
              </Card>
              <Card extra="items-center">
                <div className="text-xs uppercase text-slate-500">Projected @ end</div>
                <div className={`inline-flex items-center rounded-full px-3 py-1 text-sm font-semibold ${projectedBadge}`}>
                  ${upcoming.projectedEnd.toFixed(2)}
                </div>
              </Card>
            </section>

            <section className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-6">
              <div className="lg:col-span-2">
                <Card>
                  <h2 className="text-lg font-semibold mb-3">Add one-off</h2>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <input type="date" className="rounded-xl border p-2" value={qDate} onChange={(e) => setQDate(e.target.value)} />
                    <input type="number" className="rounded-xl border p-2" value={qAmount} onChange={(e) => setQAmount(Number(e.target.value))} placeholder="Amount (+/-)" />
                    <input type="text" className="rounded-xl border p-2" value={qNote} onChange={(e) => setQNote(e.target.value)} placeholder="Note" />
                    <button onClick={addOneOff} className="rounded-xl px-4 py-2 bg-blue-600 text-white shadow">Add</button>
                  </div>
                </Card>
              </div>

              <div>
                <Card>
                  <h2 className="text-lg font-semibold mb-3">Add recurring</h2>
                  <div className="grid grid-cols-2 gap-3">
                    <input className="rounded-xl border p-2 col-span-2" value={rLabel} onChange={(e) => setRLabel(e.target.value)} placeholder="Label" />
                    <input type="number" className="rounded-xl border p-2" value={rAmount} onChange={(e) => setRAmount(Number(e.target.value))} placeholder="Amount" />
                    <select className="rounded-xl border p-2" value={rFrequency} onChange={(e) => setRFrequency(e.target.value)}>
                      {FREQUENCIES.map((f) => <option key={f.key} value={f.key}>{f.label}</option>)}
                    </select>
                    <input type="date" className="rounded-xl border p-2" value={rAnchor} onChange={(e) => setRAnchor(e.target.value)} />
                    <input type="date" className="rounded-xl border p-2" value={rEnd} onChange={(e) => setREnd(e.target.value)} placeholder="End date" />
                    <button onClick={addRecurring} className="rounded-xl px-4 py-2 bg-blue-600 text-white shadow col-span-2">Add recurring</button>
                  </div>
                </Card>
              </div>
            </section>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
